
let
  + = $+/2,
  < = $</2,
  * = $</2,
  - = $-/2
;

let cons = \h, t => [h, ...t];

let o = \f, g, x => f (g x);

let foldr = \f, z, xs =>
  case xs of
  { []        => z
  | [h, ...t] => f h (foldr f z t)
  }
;

let map = \f => foldr (o cons f) nil;

let head = \xs =>
  case xs of
  { [h, ..._] => h
  };

let tail = \xs =>
  case xs of
  { [_, ...t] => t
  };

let nth = \n, xs =>
  case (n, xs) of
  { (0, [x, ...xs]) => x
  | (n, [x, ...xs]) => nth (- n 1) xs
  | _ => Nope ()
  };

let drop = \n, xs =>
  case (n, xs) of
  { (0, xs) => xs
  | (n, [x, ...xs]) => drop (- n 1) xs
  | _ => Nope ()
  };

let unfoldr = \z, f =>
  case f z of
  { Nothing _ => nil
  | Just pair => [pair.fst, ...unfoldr pair.snd f]
  }
;

let iterate = \z, f => [z, ...iterate (f z) f];

let if = \b, y, n =>
  case b of
  { True  _ => y
  | False _ => n
  }
;

let replace-with = \x, _ => x;

let
  sum    = foldr + 0,
  length = o sum (map (replace-with 1))
;

let take = \n, xs =>
  if (< n 1) []
    case xs of
    { []  => []
    | [h, ...t] => [h, ...take (- n 1) t]
    }
;

let count-from = \l => iterate l (+ 1);
let range = \l, h => take (+ 1 (- h l)) (count-from l);

let zip-with = \f, xs, ys =>
  case (xs, ys) of
  { ([x, ...xs], [y, ...ys]) => [f x y, ...zip-with f xs ys]
  | _                        => []
  }
;

let fib = [0, 1, ...zip-with + fib (tail fib)];