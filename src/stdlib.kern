
let
  + = $+/2,
  < = $</2,
  * = $</2,
  - = $-/2
;

let cons = \h, t => Cons {head = h, tail = t};
let nil  =          Nil {};

let o = \f, g, x => f (g x);

let foldr = \f, z, xs =>
  match xs with {
    Nil  _    => z;
    Cons pair => f pair.head (foldr f z pair.tail);
  }
;

let map = \f => foldr (o cons f) nil;

let head = \xs =>
  match xs with {
    Cons pair => pair.head;
  };

let unfoldr = \z, f =>
  match f(z) with {
    Nothing _ => nil;
    Just pair => cons pair.fst (unfoldr pair.snd f);
  }
;

let iterate = \z, f => cons z (iterate (f z) f);

let if = \b, y, n =>
  match b with {
    True  _ => y;
    False _ => n;
  }
;

let
  sum    = foldr + 0,
  length = o sum (map (\_ => 1))
;

let take = \n, xs =>
  if (< n 1)
    Nil {}
    match xs with {
      Nil  _  => Nil {};
      Cons ne => Cons {head = ne.head, tail = take (- n 1) ne.tail};
    }
;

let count-from = \l => iterate l (+ 1);
let range = \l, h => take (+ 1 (- h l)) (count-from l);

let zip-with = \f, xs, ys =>
  match xs with {
    Nil  _  => Nil {};
    Cons xs =>
      match ys with {
        Nil  _  => Nil {};
        Cons ys => cons (f xs.head ys.head) (zip-with f xs.tail ys.tail);
      };
  }
;